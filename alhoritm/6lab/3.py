def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def min_points(L, N, V):
    # Сортируем точки
    V = bubble_sort(V)
    print(V)
    # Инициализируем указатели и минимальное количество точек
    i = 0
    j = 0
    min_points = N

    while i < N and j < N:
        # Пока следующая точка в пределах диапазона L, сдвигаем правый указатель
        # Этот цикл выполняется, пока оба указателя i и j находятся в пределах списка V.
        # i - это левый указатель, который указывает на текущую точку,
        # а j - это правый указатель, который указывает на самую дальнюю точку, которую можно достичь из текущей точки.
        while j < N and V[j] - V[i] <= L: #Этот вложенный цикл выполняется,
            # пока правый указатель j находится в пределах списка V и разница между текущей точкой V[i]
            # и точкой V[j] не превышает 2 * L. Если эти условия выполняются,
            # указатель j сдвигается вправо (j += 1), что означает, что мы рассматриваем следующую точку.
            j += 1
        # Обновляем минимальное количество точек
        # Здесь мы обновляем минимальное количество точек, которое может остаться после танца.
        # N - (j - i) - это количество точек, которые находятся в диапазоне 2 * L от текущей точки.
        # Мы хотим минимизировать количество точек,
        # поэтому мы выбираем минимум между текущим значением min_points и N - (j - i)
        min_points = min(min_points, N - (j - i))
        
        # Сдвигаем левый указатель
        i += 1

    return min_points

# Тестовые данные
L = 10
N = 5
V = [30, 3, 14, 19, 21]

print("Минимальное количество точек:", min_points(L, N, V))